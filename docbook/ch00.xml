<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
<title>What is CoffeeScript?</title>
 
  
  <para>
    <ulink url="http://coffeescript.org">CoffeeScript</ulink> is a
    little language that compiles down to JavaScript. The syntax is
    inspired by Ruby and Python, and implements many features from those
    two languages. This book is designed to help you learn CoffeeScript,
    understand best practices and start building awesome client side
    applications. The book is little, only six chapters, but that's
    rather apt as CoffeeScript is a little language too.
  </para>
  <para>
    This book is completely open source, and was written by
    <ulink url="http://alexmaccaw.co.uk">Alex MacCaw</ulink> (or
    <ulink url="http://twitter.com/maccman">@maccman</ulink>) with great
    contributions from <ulink url="https://github.com/dxgriffiths">David
    Griffiths</ulink>, <ulink url="http://github.com/satyr">Satoshi
    Murakami</ulink>, <ulink url="http://www.coffeescriptlove.com">Chris
    Smith</ulink>, <ulink url="http://about.me/knoguchi">Katsuya
    Noguchi</ulink>, and
    <ulink url="https://github.com/jashkenas">Jeremy Ashkenas</ulink>.
  </para>
  <para>
    If you have any errata or suggestions, please don't hesitate to open
    a ticket on the book's
    <ulink url="https://github.com/arcturo/library">GitHub page</ulink>.
    Readers may also be interested in
    <ulink url="http://oreilly.com/catalog/9781449307530/">JavaScript
    Web Applications by O'Reilly</ulink>, a book I authored that
    explores rich JavaScript applications and moving state to the client
    side.
  </para>
  <para>
    So let's dive right into it; why is CoffeeScript better than writing
    pure JavaScript? Well for a start, there's less code to write -
    CoffeeScript is very succinct, and takes white-space into account.
    In my experience this reduces code by a third to a half of the
    original pure JavaScript. In addition, CoffeeScript has some neat
    features, such as array comprehensions, prototype aliases and
    classes that further reduce the amount of typing you need to do.
  </para>
  <para>
    More importantly though, JavaScript has a lot of
    <ulink url="http://bonsaiden.github.com/JavaScript-Garden/">skeletons
    in its closet</ulink> which can often trip up inexperienced
    developers. CoffeeScript neatly sidesteps these by only exposing a
    curated selection of JavaScript features, fixing many of the
    language's oddities.
  </para>
  <para>
    CoffeeScript is <emphasis>not</emphasis> a superset of JavaScript,
    so although you can use external JavaScript libraries from inside
    CoffeeScript, you'll get syntax errors if you compile JavaScript
    as-is, without converting it. The compiler converts CoffeeScript
    code into its counterpart JavaScript, there's no interpretation at
    runtime.
  </para>
  <para>
    First to get some common fallacies out the way. You will need to
    know JavaScript in order to write CoffeeScript, as runtime errors
    require JavaScript knowledge. However, having said that, runtime
    errors are usually pretty obvious, and so far I haven't found
    mapping JavaScript back to CoffeeScript to be an issue. The second
    problem I've often heard associated with CoffeeScript is speed; i.e.
    the code produced by the CoffeeScript compiler would run slower than
    its equivalent written in pure JavaScript. In practice though, it
    turns out this isn't a problem either. CoffeeScript tends to run as
    fast, or faster than hand-written JavaScript.
  </para>
  <para>
    What are the disadvantages of using CoffeeScript? Well, it
    introduces another compile step between you and your JavaScript.
    CoffeeScript tries to mitigate the issue as best it can by producing
    clean and readable JavaScript, and with its server integrations
    which automate compilation. The other disadvantage, as with any new
    language, is the fact that the community is still small at this
    point, and you'll have a hard time finding fellow collaborators who
    already know the language. CoffeeScript is quickly gaining momentum
    though, and its IRC list is well staffed; any questions you have are
    usually answered promptly.
  </para>
  <para>
    CoffeeScript is not limited to the browser, and can be used to great
    effect in server side JavaScript implementations, such as
    <ulink url="http://nodejs.org/">Node.js</ulink>. Additionally,
    CoffeeScript is getting much wider use and integration, such as
    being a default in Rails 3.1. Now is definitely the time to jump on
    the CoffeeScript train. The time you invest in learning about the
    language now will be repaid by major time savings later.
  </para>
  <sect1>
    <title>Initial setup</title>
    <para>
      One of the easiest ways to initially play around with the library
      is to use it right inside the browser. Navigate to
      <ulink url="http://coffeescript.org">http://coffeescript.org</ulink>
      and click on the <emphasis>Try CoffeeScript</emphasis> tab. The
      site uses a browser version of the CoffeeScript compiler,
      converting any CoffeeScript typed inside the left panel to
      JavaScript in the right panel.
    </para>
    <para>
      You can also convert JavaScript back to CoffeeScript using the
      <ulink url="http://js2coffee.org/">js2coffee</ulink> project,
      especially useful when migrating JavaScript projects to
      CoffeeScript.
    </para>
    <para>
      In fact, you can use the browser-based CoffeeScript compiler
      yourself, by including
      <ulink url="http://jashkenas.github.com/coffee-script/extras/coffee-script.js">this
      script</ulink> in a page, marking up any CoffeeScript script tags
      with the correct <literal>type</literal>.
    </para>
    <screen>
&lt;script src="http://jashkenas.github.com/coffee-script/extras/coffee-script.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script type="text/coffeescript"&gt;
  # Some CoffeeScript
&lt;/script&gt;
</screen>
    <para>
      Obviously, in production, you don't want to be interpreting
      CoffeeScript at runtime as it'll slow things up for your clients.
      Instead CoffeeScript offers a
      <ulink url="http://nodejs.org">Node.js</ulink> compiler to
      pre-process CoffeeScript files.
    </para>
    <para>
      To install it, first make sure you have a working copy of the
      latest stable version of
      <ulink url="http://nodejs.org">Node.js</ulink>, and
      <ulink url="http://npmjs.org/">npm</ulink> (the Node Package
      Manager). You can then install CoffeeScript with npm:
    </para>
    <screen>
npm install -g coffee-script
</screen>
    <para>
      The <literal>-g</literal> flag is important, as it tells npm to
      install the <literal>coffee-script</literal> package globally,
      rather than locally. Without it, you won't get the
      <literal>coffee</literal> executable.
    </para>
    <para>
      If you execute the <literal>coffee</literal> executable without
      any command line options, it'll give you the CoffeeScript console,
      which you can use to quickly execute CoffeeScript statements. To
      pre-process files, pass the <literal>--compile</literal> option.
    </para>
    <screen>
coffee --compile my-script.coffee
</screen>
    <para>
      If <literal>--output</literal> is not specified, CoffeeScript will
      write to a JavaScript file with the same name, in this case
      <literal>my-script.js</literal>. This will overwrite any existing
      files, so be careful you're not overwriting any JavaScript files
      unintentionally. For a full list of the command line options
      available, pass <literal>--help</literal>.
    </para>
    <para>
      You can also pass the <literal>--compile</literal> option a
      directory, and CoffeeScript will recursively compile every file
      with a <literal>.coffee</literal> extension:
    </para>
    <screen>
coffee --output lib --compile src
</screen>
    <para>
      Even calling that is a bit of a bore, so let's look into
      automating it.
    </para>
  </sect1>
  <sect1>
    <title>Cake</title>
    <para>
      <ulink url="http://jashkenas.github.com/coffee-script/#cake">Cake</ulink>
      is a super simple build system along the lines of
      <ulink url="http://www.gnu.org/software/make/">Make</ulink> and
      <ulink url="http://rake.rubyforge.org/">Rake</ulink>. The library
      is bundled with the <literal>coffee-script</literal> npm package,
      and available via an executable called <literal>cake</literal>.
    </para>
    <para>
      You can define tasks using CoffeeScript in a file called
      <literal>Cakefile</literal>. Cake will pick these up, and can be
      invoked by running <literal>cake [task] [options]</literal> from
      within the directory. To print a list of all the tasks and
      options, just type <literal>cake</literal>.
    </para>
    <para>
      Tasks are defined using the <literal>task()</literal> function,
      passing a name, optional description and callback function. For
      example, create a file called <literal>Cakefile</literal>, and two
      directories, <literal>lib</literal> and <literal>src</literal>.
      Add the following to the <literal>Cakefile</literal>:
    </para>
    <screen>
fs = require 'fs'

{print} = require 'sys'
{spawn} = require 'child_process'

build = (callback) -&gt;
  coffee = spawn 'coffee', ['-c', '-o', 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
  coffee.on 'exit', (code) -&gt;
    callback?() if code is 0

task 'build', 'Build lib/ from src/', -&gt;
  build()
</screen>
    <para>
      In the example above, we're defining a task called
      <literal>build</literal> that can be invoked by running:
      <literal>cake build</literal>. This runs the same command as the
      previous example, compiling all the CoffeeScript files in
      <literal>src</literal> to JavaScript in <literal>lib</literal>.
      You can now reference JavaScript files in the
      <literal>lib</literal> directory as per usual from your HTML:
    </para>
    <screen>
&lt;script src="lib/app.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;      
</screen>
    <para>
      We're still having to manually run <literal>cake build</literal>
      whenever our CoffeeScript code changes, which is far from ideal.
      Luckily, the <literal>coffee</literal> command takes another
      option, <literal>--watch</literal>, which instructs it to watch a
      directory for changes and re-compiling as necessary. Let's define
      another task using that:
    </para>
    <screen>
task 'watch', 'Watch src/ for changes', -&gt;
  coffee = spawn 'coffee', ['-w', '-c', '-o', 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
</screen>
    <para>
      If one task relies on another, you can run other tasks using
      <literal>invoke(name)</literal>. Let's add a utility task to our
      <literal>Cakefile</literal> which is going to both open
      <literal>index.html</literal> and start watching the source for
      changes.
    </para>
    <screen>
task 'open', 'Open index.html', -&gt;
  # First open, then watch
  spawn 'open', 'index.html'
  invoke 'watch'
</screen>
    <para>
      You can also define options for your task using the
      <literal>option()</literal> function, which takes a short name,
      long name and description.
    </para>
    <screen>
option '-o', '--output [DIR]', 'output dir'

task 'build', 'Build lib/ from src/', -&gt;
  # Now we have access to a `options` object
  coffee = spawn 'coffee', ['-c', '-o', options.output or 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
</screen>
    <para>
      As you can see, the task context now has access to an
      <literal>options</literal> object containing any data specified by
      the user. If we run <literal>cake</literal> without any other
      arguments, all the tasks and options will be listed.
    </para>
    <para>
      Cake's a great way of automating common tasks such as compiling
      CoffeeScript without going to the hassle of using bash or
      Makefiles. It's also worth taking a look at
      <ulink url="http://jashkenas.github.com/coffee-script/documentation/docs/cake.html">Cake's
      source</ulink>, a great example of CoffeeScript's expressiveness
      and beautifully documented alongside the code comments.
    </para>
  </sect1>
  <sect1>
    <title>Server side compilation</title>
    <para>
      Using Cake for CoffeeScript compilation is fine for static sites,
      but for dynamic sites we might as well integrate CoffeeScript
      compilation into the request/response cycle. Various integration
      solutions already exist for the popular backend languages and
      frameworks, such as
      <ulink url="http://rubyonrails.org/">Rails</ulink> and
      <ulink url="https://www.djangoproject.com/">Django</ulink>.
    </para>
    <para>
      When it comes to Rails 3.1, CoffeeScript support comes via
      <ulink url="https://github.com/sstephenson/sprockets">Sprockets
      &amp; the asset pipeline</ulink>. Add your CoffeeScript files
      under <literal>app/assets/javascripts</literal>, and Rails is
      smart enough to pre-compile them when they're requested.
      JavaScript &amp; CoffeeScript files are concatenated and bundled
      using special comment directives, meaning you can fetch all of
      your application's JavaScript with one request. When it comes to
      production, Rails will write the compiled output to disk, ensuring
      it's cached and fast to serve.
    </para>
    <para>
      Other Ruby options include Rack servers such as 37signal's
      <ulink url="http://pow.cx/">Pow</ulink> and Joshua Peek's
      <ulink url="http://josh.github.com/nack/">Nack</ulink>, both
      highly recommended if your application doesn't need Rail's other
      features and associated overhead.
    </para>
    <para>
      Django also has
      <ulink url="http://pypi.python.org/pypi/django-coffeescript/">support
      for CoffeeScript</ulink> through special template tags. It works
      with both inline code and external files.
    </para>
    <para>
      Both Ruby and Python pipe out to Node and the CoffeeScript lib
      behind the scenes when compiling CoffeeScript, so you'll need to
      have those installed during development. If you're using Node
      directly as a backend for your site, CoffeeScript integration is
      even simpler and you can use it for both the backend and frontend
      code. We're going to talk more about this in the next chapter,
      using
      <ulink url="https://github.com/sstephenson/stitch">Stitch</ulink>
      to serve all our client-side CoffeeScript.
    </para>
  </sect1>


</chapter>